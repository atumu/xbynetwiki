location:lua/lua基础学习之标准库
createAt:2016-12-22 17:31:11
modifyAt:2016-12-22 17:35:43
author:xbynet
title:Lua基础学习之标准库

# C API接口
由于，目前关注重点在于简单的redis与Lua及nginx与lua交互，故而暂时略去此部分学习。。。

# 标准库
所有的库都是直接用 C API 实现的，并以分离的 C 模块形式提供。 目前，Lua 有下列标准库：
基础库
协程库 
包管理库 
字符串控制 
基础 UTF-8 支持
表控制
数学函数
输入输出
操作系统库
调试库

## 基础函数
(只列出一些个人认为对初学者常用的)

**assert (v [, message])**
如果其参数 v 的值为假（nil 或 false）， 它就调用 error； 否则，返回所有的参数。 在错误情况时， message 指那个错误对象； 如果不提供这个参数，参数默认为 "assertion failed!" 。

**dofile ([filename])**
打开该名字的文件，并执行文件中的 Lua 代码块。

**error (message [, level])**
中止上一次保护函数调用， 将错误对象 message 返回。level 参数指明了怎样获得出错位置。 对于 level 1 （默认值），出错位置指 error 函数调用的位置。 Level 2 将出错位置指向调用 error的函数的函数；以此类推。 传入 level 0 可以避免在消息前添加出错位置信息。

**_G**
一个全局变量（非函数）， 内部储存有全局环境。 Lua 自己不使用这个变量； 改变这个变量的值不会对任何环境造成影响，反之亦然。

**_VERSION**
一个包含有当前解释器版本号的全局变量（并非函数）。 当前这个变量的值为 "Lua 5.3"。

**getmetatable (object)**
如果 object 不包含元表，返回 nil 。 否则，如果在该对象的元表中有 "__metatable" 域时返回其关联值， 没有时返回该对象的元表。

**ipairs (t)**
以下代码for i,v in ipairs(t) do body end
将迭代键值对（1,t[1]) ，(2,t[2])， ... ，直到第一个空值。

**pairs (t)**
for k,v in pairs(t) do body end
能迭代表 t 中的所有键值对。

**load (chunk [, chunkname [, mode [, env]]])**
加载一个代码块。
如果 chunk 是一个字符串，代码块指这个字符串。 如果 chunk 是一个函数， load 不断地调用它获取代码块的片断。 每次对 chunk 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。 当返回空串、nil、或是不返回值时，都表示代码块结束。
**如果没有语法错误， 则以函数形式返回编译好的代码块； 否则，返回 nil 加上错误消息。**
如果结果函数有上值， env 被设为第一个上值。 若不提供此参数，将全局环境替代它。
chunkname 在错误消息和调试消息中，用于代码块的名字。 如果不提供此参数，它默认为字符串chunk 。
字符串 mode 用于控制代码块是文本还是二进制（即预编译代码块）。 它可以是字符串 "b" （只能是二进制代码块）， "t" （只能是文本代码块）， 或 "bt" （可以是二进制也可以是文本）。 默认值为 "bt"。

**loadfile ([filename [, mode [, env]]])**
和 load 类似， 不过是从文件 filename 或标准输入（如果文件名未提供）中获取代码块。

**next (table [, index])**
运行程序来遍历表中的所有域。 第一个参数是要遍历的表，第二个参数是表中的某个键。 next 返回该键的下一个键及其关联的值。 特别指出，**你可以用 next(t) 来判断一张表是否是空的。**

**pcall (f [, arg1, ···])**
传入参数，以 **保护模式 调用函数** f 。 这意味着 f 中的任何错误不会抛出； 取而代之的是，pcall 会将错误捕获到，并返回一个状态码。 第一个返回值是状态码（一个布尔量）， 当没有错误时，其为真。 此时，pcall 同样会在状态码后返回所有调用的结果。 在有错误时，pcall 返回 false 加错误消息。

**xpcall (f, msgh [, arg1, ···])**
这个函数和 pcall 类似。 不过它可以额外设置一个消息处理器 msgh。

**print (···)**
接收任意数量的参数，并将它们的值打印到 stdout。 它用 `tostring` 函数将每个参数都转换为字符串。 **print 不用于做格式化输出。**完整的对输出的控制，请使用 `string.format` 以及 `io.write`。

**tostring (v)**
可以接收任何类型，它将其转换为人可阅读的字符串形式。 

**select (index, ···)**
如果 index 是个数字， 那么返回参数中第 index 个之后的部分； 负的数字会从后向前索引（-1 指最后一个参数）。 否则，index 必须是字符串 "#"， 此时 select 返回参数的个数。

**tonumber (e [, base])**
如果调用的时候没有 base， tonumber 尝试把参数转换为一个数字。

**type (v)**
类型判断， 函数可能的返回值有 "nil" （一个字符串，而不是 nil 值）， "number"， "string"， "boolean"， "table"， "function"， "thread"， "userdata"。

## 协程管理
关于协程的操作作为基础库的一个子库， 被放在一个独立表 coroutine 中。

coroutine.create (f)
创建一个主体函数为 f 的新协程。 f 必须是一个 Lua 的函数。 返回这个新协程，它是一个类型为 "thread" 的对象。

coroutine.isyieldable ()
如果正在运行的协程可以让出，则返回真。
不在主线程中或不在一个无法让出的 C 函数中时，当前协程是可让出的。

coroutine.resume (co [, val1, ···])
开始或继续协程 co 的运行。 当你第一次延续一个协程，它会从主体函数处开始运行。 val1, ... 这些值会以参数形式传入主体函数。 如果该协程被让出，resume 会重新启动它； val1, ... 这些参数会作为让出点的返回值。

如果协程运行起来没有错误， resume 返回 true 加上传给 yield 的所有值 （当协程让出）， 或是主体函数的所有返回值（当协程中止）。 如果有任何错误发生， resume 返回 false 加错误消息。

coroutine.running ()
返回当前正在运行的协程加一个布尔量。 如果当前运行的协程是主线程，其为真。

coroutine.status (co)
以字符串形式返回协程 co 的状态： 当协程正在运行（它就是调用 status 的那个） ，返回 "running"； 如果协程调用 yield 挂起或是还没有开始运行，返回 "suspended"； 如果协程是活动的，都并不在运行（即它正在延续其它协程），返回 "normal"； 如果协程运行完主体函数或因错误停止，返回 "dead"。

coroutine.wrap (f)
创建一个主体函数为 f 的新协程。 f 必须是一个 Lua 的函数。 返回一个函数， 每次调用该函数都会延续该协程。 传给这个函数的参数都会作为 resume 的额外参数。 和 resume 返回相同的值， 只是没有第一个布尔量。 如果发生任何错误，抛出这个错误。

coroutine.yield (···)
挂起正在调用的协程的执行。 传递给 yield 的参数都会转为 resume 的额外返回值。

## 模块
包管理库提供了从 Lua 中加载模块的基础库。 只有一个导出函数直接放在全局环境中： `require`。 所有其它的部分都导出在表 `package` 中。

**require (modname)**
加载一个模块。 这个函数首先查找 `package.loaded` 表， 检测 modname 是否被加载过。 如果被加载过，require 返回 package.loaded[modname] 中保存的值。 否则，它试着为模块寻找 加载器 。(require 遵循 package.searchers 序列的指引来查找加载器。)

**package.path**
这个路径被 require 在 Lua 加载器中做搜索时用到。
在启动时，Lua 用环境变量 LUA_PATH_5_3 或环境变量 `LUA_PATH` 来初始化这个变量。

**package.searchers**
用于 require 控制如何加载模块的表。

**package.searchpath (name, path [, sep [, rep]])**
在指定 path 中搜索指定的 name 。

其余，请看文档。

## 字符串处理
这个库提供了字符串处理的通用函数。 例如字符串查找、子串、模式匹配等。 当在 Lua 中对字符串做索引时，**第一个字符从 1 开始计算（而不是 C 里的 0 ）**。 索引可以是负数，它指从字符串末尾反向解析。 即，最后一个字符在 -1 位置处，等等。
字符串库中的所有函数都在表 string 中。字符串库假定采用单字节字符编码。(这意味着不是原生支持中文。)

**string.byte (s [, i [, j]])**
返回字符 s[i]， s[i+1]， ...　，s[j] 的内部数字编码。

**string.char (···)**
接收零或更多的整数。 返回和参数数量相同长度的字符串。

**string.find (s, pattern [, init [, plain]])**
查找第一个字符串 s 中匹配到的 pattern 。 如果找到一个匹配，find 会返回 s 中关于它起始及终点位置的索引； 否则，返回 nil。 第三个可选数字参数 init 指明从哪里开始搜索； 默认值为 1 ，同时可以是负值。 第四个可选参数 plain 为 true 时， 关闭模式匹配机制。 此时函数仅做直接的 “查找子串”的操作.

**string.format (formatstring, ···)**
返回不定数量参数的格式化版本， 格式化串为第一个参数（必须是一个字符串）。 格式化字符串遵循 ISO C 函数 sprintf 的规则。

**string.match (s, pattern [, init])**
在字符串 s 中找到第一个能用 pattern （参见 §6.4.1）匹配到的部分。 如果能找到，match 返回其中的捕获物； 否则返回 nil 。 如果 pattern 中未指定捕获， 返回整个 pattern 捕获到的串。 第三个可选数字参数 init 指明从哪里开始搜索； 它默认为 1 且可以是负数。

**string.gmatch (s, pattern)**
返回一个迭代器函数。 每次调用这个函数都会继续以 pattern （参见　§6.4.1） 对 s 做匹配，并返回所有捕获到的值。 如果 pattern 中没有指定捕获，则每次捕获整个 pattern。
下面这个例子会循环迭代字符串 s 中所有的单词， 并逐行打印：

     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end

下一个例子从指定的字符串中收集所有的键值对 key=value 置入一张表：

     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end

对这个函数来说，模板前开始的 '^' 不会当成锚点。因为这样会阻止迭代。

**string.sub (s, i [, j])**
返回 s 的子串， 该子串从 i 开始到 j 为止； i 和 j 都可以为负数。

**string.gsub (s, pattern, repl [, n])**
将字符串 s 中，所有的（或是在 n 给出时的前 n 个） pattern （参见 §6.4.1）都替换成 repl ，并返回其副本。 repl 可以是字符串、表、或函数。 gsub 还会在第二个返回值返回一共发生了多少次匹配。 这个和python中的re.sub有点类似。
如果 repl 是一个字符串，那么把这个字符串作为替换品。 字符 % 是一个转义符： repl 中的所有形式为 %d 的串表示 第 d 个捕获到的子串，d 可以是 1 到 9 。 串 %0 表示整个匹配。 串 %% 表示单个 %。
如果 repl 是张表，每次匹配时都会用第一个捕获物作为键去查这张表。
如果 repl 是个函数，则在每次匹配发生时都会调用这个函数。 所有捕获到的子串依次作为参数传入。
这里有一些用例：

     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --> x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --> x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --> x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --> x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --> x="4+5 = 9"
     
     local t = {name="lua", version="5.3"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --> x="lua-5.3.tar.gz"
     
**string.len (s)**
接收一个字符串，返回其长度。 空串 "" 的长度为 0 。

**string.lower (s)**
接收一个字符串，将其中的大写字符都转为小写后返回其副本。 
**string.upper (s)**

**string.pack (fmt, v1, v2, ···)**
string.unpack (fmt, s [, pos])
返回一个打包了（即以二进制形式序列化） v1, v2 等值的二进制字符串。 字符串 fmt 为打包格式

**string.rep (s, n [, sep])**
返回 n 个字符串 s 以字符串 sep 为分割符连在一起的字符串。 默认的 sep 值为空字符串（即没有分割符）。

**string.reverse (s)**
返回字符串 s 的翻转串。


### 匹配模式
Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 `string.find, string.gmatch, string.gsub, string.match`。 

字符类：
字符类 用于表示一个字符集合。 下列组合可用于字符类：

```
x: （这里 x 不能是 魔法字符 ^$()%.[]*+-? 中的一员） 表示字符 x 自身。
.: （一个点）可表示任何字符。
%a: 表示任何字母。
%c: 表示任何控制字符。
%d: 表示任何数字。
%g: 表示任何除空白符外的可打印字符。
%l: 表示所有小写字母。
%p: 表示所有标点符号。
%s: 表示所有空白字符。
%u: 表示所有大写字母。
%w: 表示所有字母及数字。
%x: 表示所有 16 进制数字符号。
%x: （这里的 x 是任意非字母或数字的字符） 表示字符 x。 这是对魔法字符转义的标准方法。 所有非字母或数字的字符 （包括所有标点，也包括非魔法字符） 都可以用前置一个 '%' 放在模式串中表示自身。
[set]: 表示 set　中所有字符的联合。 可以以 '-' 连接，升序书写范围两端的字符来表示一个范围的字符集。 上面提到的 %x 形式也可以在 set 中使用 表示其中的一个元素。 其它出现在 set 中的字符则代表它们自己。 例如，[%w_] （或 [_%w]） 表示所有的字母数字加下划线）， [0-7] 表示 8 进制数字， [0-7%l%-]　表示 8 进制数字加小写字母与 '-' 字符。
交叉使用类和范围的行为未定义。 因此，像 [%a-z] 或 [a-%%] 这样的模式串没有意义。

[^set]: 表示 set 的补集， 其中 set 如上面的解释。
所有单个字母表示的类别（%a，%c，等）， 若将其字母改为大写，均表示对应的补集。 例如，%S 表示所有非空格的字符。
```

如何定义字母、空格、或是其他字符组取决于当前的区域设置。 特别注意：[ a-z ]　未必等价于 %l 。

模式条目：
模式条目 可以是
单个字符类匹配该类别中任意单个字符；
单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；
单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；
单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；
单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；
%n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。
%bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。
%f[ set ]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\0' 一样。
模式：

模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。

捕获：
模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 "(a*(.)%w(%s*))" ， 字符串中匹配到 "a*(.)%w(%s*)" 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 "." 匹配到的字符是 2 号捕获物， 匹配到 "%s*" 的那部分是 3 号。

作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 "()aa()" 作用到字符串 "flaaap" 上，将产生两个捕获物： 3 和 5 。


### UTF-8 支持
这个库提供了对 UTF-8 编码的基础支持。 所有的函数都放在表 utf8 中。

utf8.char (···)
接收零或多个整数， 将每个整数转换成对应的 UTF-8 字节序列，并返回这些序列连接到一起的字符串。

**utf8.charpattern**
用于精确匹配到一个 UTF-8 字节序列的模式（是一个字符串，并非函数）"[\0-\x7F\xC2-\xF4][\x80-\xBF]*"

**utf8.len (s [, i [, j]])**
返回字符串 s 中 从位置 i 到 j 间 （包括两端） UTF-8 字符的个数。 默认的 i 为 1 ，默认的 j 为 -1 。

**utf8.offset (s, n [, i])**
返回编码在 s 中的第 n 个字符的开始位置（按字节数） （从位置 i 处开始统计）。

其余看文档

## 表处理
这个库提供了表处理的通用函数。 所有函数都放在表 table 中。

**table.concat (list [, sep [, i [, j]]])**
返回字符串 list[i]..sep..list[i+1] ··· sep..list[j]。 sep 的默认值是空串， i 的默认值是 1 ， j 的默认值是 #list 。 如果 i 比 j 大，返回空串。

**table.insert (list, [pos,] value)**
在 list 的位置 pos 处插入元素 value ， 并后移元素 list[pos], list[pos+1], ···, list[#list] 。 pos 的默认值为 #list+1 ， 因此调用 table.insert(t,x) 会将 x 插在列表 t 的末尾。

**table.remove (list [, pos])**
移除 list 中 pos 位置上的元素，并返回这个被移除的值。 

**table.sort (list [, comp])**
在表内从 list[1] 到 list[#list] 原地 对其间元素按指定次序排序。 如果提供了 comp ， 它必须是一个可以接收两个列表内元素为参数的函数。 当第一个元素需要排在第二个元素之前时，返回真 （因此 not comp(list[i+1],list[i]) 在排序结束后将为真）。

**table.pack (···)**
返回用所有参数以键 1,2, 等填充的新表， 并将 "n" 这个域设为参数的总数。 注意这张返回的表不一定是一个序列。

**table.unpack (list [, i [, j]])**
返回列表中的元素。 这个函数等价于
return list[i], list[i+1], ···, list[j]
i 默认为 1 ，j 默认为 #list。

## 数学函数
这个库提供了基本的数学函数。 所以函数都放在表 math 中。
略。。。

## 输入输出库
I/O 库提供了两套不同风格的文件处理接口。 第一种风格使用隐式的文件句柄； 它提供设置默认输入文件及默认输出文件的操作， 所有的输入输出操作都针对这些默认文件。 第二种风格使用显式的文件句柄。

**当使用隐式文件句柄时， 所有的操作都由表 io 提供。 若使用显式文件句柄， `io.open` 会返回一个文件句柄，且所有的操作都由该文件句柄的方法来提供。**

表 io 中也提供了三个 和 C 中含义相同的预定义文件句柄： `io.stdin， io.stdout， 以及 io.stderr`。 I/O 库永远不会关闭这些文件。

I/O 函数在出错时都返回 nil （第二个返回值为错误消息，第三个返回值为系统相关的错误码）。 成功时返回与 nil 不同的值。

隐式文件句柄操作

**io.close ([file])**
等价于 file:close()。 不给出 file 时将关闭默认输出文件。

**io.flush ()**

**io.lines ([filename ···])**
以**读模式**打开指定的文件名并返回一个**迭代函数**。 此迭代函数的工作方式和用一个已打开的文件去调用 file:lines(···) 得到的迭代器相同。 当迭代函数检测到文件结束， 它不返回值（让循环结束）并**自动关闭文件**。
调用 io.lines() （不传文件名） 等价于 io.input():lines("*l")； 即，它将按行迭代标准输入文件。 在此情况下，循环结束后它不会关闭文件。

**io.open (filename [, mode])**
这个函数用字符串 mode 指定的模式打开一个文件。 返回新的文件句柄。 当出错时，返回 nil 加错误消息。
mode 字符串可以是下列任意值：
"r": 读模式（默认）；
"w": 写模式；
"a": 追加模式；
"r+": 更新模式，所有之前的数据都保留；
"w+": 更新模式，所有之前的数据都删除；
"a+": 追加更新模式，所有之前的数据都保留，只允许在文件尾部做写入。
mode 字符串可以在最后加一个 'b' ， 这会在某些系统上以二进制方式打开文件。

**io.popen (prog [, mode])**
这个函数和系统有关，不是所有的平台都提供。
用一个分离进程开启程序 prog， 返回的文件句柄可用于从这个程序中读取数据 （如果 mode 为 "r"，这是默认值） 或是向这个程序写入输入（当 mode 为 "w" 时）。

**io.input ([file])**
用文件名调用它时，（以文本模式）来打开该名字的文件， 并将文件句柄设为默认输入文件。 如果用文件句柄去调用它， 就简单的将该句柄设为默认输入文件。 如果调用时不传参数，它返回当前的默认输入文件。

**io.read (···)**
等价于 io.input():read(···)。

**io.tmpfile ()**
返回一个临时文件的句柄。 这个文件以更新模式打开，**在程序结束时会自动删除。**

**io.type (obj)**
检查 obj 是否是合法的文件句柄。 如果 obj 它是一个打开的文件句柄，返回字符串 "file"。 如果 obj 是一个关闭的文件句柄，返回字符串 "closed file"。 如果 obj 不是文件句柄，返回 nil 。

**io.output ([file])**
类似于 io.input。 不过都针对默认输出文件操作。

**io.write (···)**
等价于 io.output():write(···)。

显式文件句柄操作
若使用显式文件句柄， `io.open` 会返回一个文件句柄

**file:close ()**
关闭 file。

**file:flush ()**
将写入的数据保存到 file 中。

**file:lines (···)**
返回一个迭代器函数， 每次调用迭代器时，都从文件中按指定格式读数据。 如果没有指定格式，使用默认值 "l" 。 看一个例子

    for c in file:lines(1) do body end

会从文件当前位置开始，中不断读出字符。 **`和 io.lines 不同， 这个函数在循环结束后不会关闭文件。`**

**file:read (···)**
读文件 file， 指定的格式决定了要读什么。 对于每种格式，函数返回读出的字符对应的字符串或数字。 若不能以该格式对应读出数据则返回 nil。 （对于最后这种情况， 函数不会读出后续的格式。） 当调用时不传格式，它会使用默认格式读下一行（见下面描述）。
提供的格式有
"n": 读取一个数字，根据 Lua 的转换文法，可能返回浮点数或整数。 （数字可以有前置或后置的空格，以及符号。） 只要能构成合法的数字，这个格式总是去读尽量长的串； 如果读出来的前缀无法构成合法的数字 （比如空串，"0x" 或 "3.4e-"）， 就中止函数运行，返回 nil。
"i": 读取一个整数，返回整数值。
**"a": 从当前位置开始读取整个文件。 如果已在文件末尾，返回空串。**
**"l": 读取一行并忽略行结束标记。 当在文件末尾时，返回 nil 这是默认格式。**
"L": 读取一行并保留行结束标记（如果有的话）， 当在文件末尾时，返回 nil。
number: 读取一个不超过这个数量字节数的字符串。 当在文件末尾时，返回 nil。 如果 number 为零， 它什么也不读，返回一个空串。 当在文件末尾时，返回 nil。
格式 "l" 和 "L" 只能用于文本文件。

**file:seek ([whence [, offset]])**
设置及获取基于文件开头处计算出的位置。 设置的位置由 offset 和 whence 字符串 whence 指定的基点决定。基点可以是：
"set": 基点为 0 （文件开头）；
"cur": 基点为当前位置了；
"end": 基点为文件尾；
当 seek 成功时，返回最终从文件开头计算起的文件的位置。 当 seek 失败时，返回 nil 加上一个错误描述字符串。
whence 的默认值是 "cur"， offset 默认为 0 。 因此，调用 file:seek() 可以返回文件当前位置，并不改变它； 调用 file:seek("set") 将位置设为文件开头（并返回 0）； 调用 file:seek("end") 将位置设到文件末尾，并返回文件大小。

file:setvbuf (mode [, size])
设置输出文件的缓冲模式。 有三种模式：
"no": 不缓冲；输出操作立刻生效。
"full": 完全缓冲；只有在缓存满或当你显式的对文件调用 flush（参见 io.flush） 时才真正做输出操作。
"line": 行缓冲； 输出将到每次换行前， 对于某些特殊文件（例如终端设备）缓冲到任何输入前。
对于后两种情况，size 以字节数为单位 指定缓冲区大小。 默认会有一个恰当的大小。

**file:write (···)**
将参数的值逐个写入 file。 参数必须是字符串或数字。
成功时，函数返回 file。 否则返回 nil 加错误描述字符串。

## 操作系统库
这个库都通过表 os 实现。

**os.clock ()**
返回程序使用的按秒计 CPU 时间的近似值。

**os.date ([format [, time]])**
返回一个包含日期及时刻的字符串或表。 格式化方法取决于所给字符串 format。
如果提供了 time 参数， 格式化这个时间 （这个值的含义参见 os.time 函数）。 否则，date 格式化当前时间。
如果 format 以 '!' 打头， 日期以协调世界时格式化。 在这个可选字符项之后， 如**果 format 为字符串 "*t"，** date 返回有后续域的表： year （四位数字），month （1–12），day （1–31）， hour （0–23），min （0–59），sec （0–61）， wday （星期几，星期天为 1 ）， yday （当年的第几天）， 以及 isdst （夏令时标记，一个布尔量）。 对于最后一个域，如果该信息不提供的话就不存在。
**如果 format 并非 "*t"， date 以字符串形式返回， 格式化方法遵循 ISO C 函数 strftime 的规则。**

**os.difftime (t2, t1)**
返回以秒计算的时刻 t1 到 t2 的差值。 （这里的时刻是由 os.time 返回的值）。

**os.execute ([command])**
它调用系统解释器执行 command。 如果命令成功运行完毕，第一个返回值就是 true， 否则是 nil。 在第一个返回值之后，函数返回一个字符串加一个数字。如下：
"exit": 命令正常结束； 接下来的数字是命令的退出状态码。
"signal": 命令被信号打断； 接下来的数字是打断该命令的信号。

**os.exit ([code [, close]])**
调用 ISO C 函数 exit 终止宿主程序。 如果 code 为 true， 返回的状态码是 EXIT_SUCCESS； 如果 code 为 false， 返回的状态码是 EXIT_FAILURE； 如果 code 是一个数字， 返回的状态码就是这个数字。 code 的默认值为 true。

**os.getenv (varname)**
返回进程环境变量 varname 的值， 如果该变量未定义，返回 nil 。

**os.remove (filename)**
删除指定名字的文件（在 POSIX 系统上可以是一个空目录） 如果函数失败，返回 nil 加一个错误描述串及出错码。

**os.rename (oldname, newname)**
将名字为 oldname 的文件或目录更名为 newname。 如果函数失败，返回 nil 加一个错误描述串及出错码。

**os.time ([table])**
当不传参数时，返回当前时刻。 如果传入一张表，就返回由这张表表示的时刻。 这张表必须包含域 year，month，及 day； 可以包含有　hour （默认为 12 ）， min （默认为 0）， sec （默认为 0），以及 isdst （默认为 nil）。

## 调试库
这个库里的所有函数都提供在表 `debug` 内。 所有操作线程的函数，可选的第一个参数都是针对的线程。 默认值永远是当前线程。

**debug.traceback ([thread,] [message [, level]])**
如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。 否则，它返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。
其他，请看文档

