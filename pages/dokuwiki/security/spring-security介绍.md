title: spring-security介绍 

#  Spring-Security入门 
本文基于Spring-Security3.2版本
官方文档：http://docs.spring.io/spring-security/site/docs/3.2.9.RELEASE/reference/htmlsingle/
Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。
Maven：
```

<spring.security.version>3.2.9.RELEASE</spring.security.version>
<dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-web</artifactId>
            <version>${spring.security.version}</version>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-config</artifactId>
            <version>${spring.security.version}</version>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
            <version>${spring.security.version}</version>
            <scope>compile</scope>
        </dependency>
	 <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-taglibs</artifactId>
            <version>${spring.security.version}</version>
            <scope>runtime</scope>
        </dependency>
		<dependency>
			<groupId>javax.annotation</groupId>
			<artifactId>javax.annotation-api</artifactId>
			<version>1.2-b01</version>
		</dependency>

```


**授权服务方式**：一、全局方法安全注解。二、定义方法拦截规则。三、定义URL拦截规则。

配置方式：一、Java注解配置。二、XML配置

##  Schema基础数据 
namespace:
```

<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:security="http://www.springframework.org/schema/security"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/security
          http://www.springframework.org/schema/security/spring-security.xsd">
    ...
</beans>
不过一般将security配置单独放一个文件上，所以一般将security作为根namespace
<beans:beans xmlns="http://www.springframework.org/schema/security"
  xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/security
           http://www.springframework.org/schema/security/spring-security.xsd">
    ...
</beans:beans>

```
User Schema：
```

create table users(
    username varchar_ignorecase(50) not null primary key,
    password varchar_ignorecase(50) not null,
    enabled boolean not null
);

create table authorities (
    username varchar_ignorecase(50) not null,
    authority varchar_ignorecase(50) not null,
    constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);

```
Group Authorities:
```

create table groups (
    id bigint generated by default as identity(start with 0) primary key,
    group_name varchar_ignorecase(50) not null
);

create table group_authorities (
    group_id bigint not null,
    authority varchar(50) not null,
    constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
    id bigint generated by default as identity(start with 0) primary key,
    username varchar(50) not null,
    group_id bigint not null,
    constraint fk_group_members_group foreign key(group_id) references groups(id)
);

```

##  选择并配置AuthenticationProvider 
以下将会示例几种方式的提供者配置，主要基于Java配置方式。
###  DaoAuthticationProvider 
` DaoAuthticationProvider `的核心概念就是：它将使用dao对象以` UserDetailsService `实现的形式，按照用户名从数据库中获取` UserDetails `对象。UserDetails对象包含了关于用户的信息，例如用户名和密码、GrantedAuthority、以及用户是否被启用、过期和锁定了。当然，你不用担心认证用户的细节。这些对你都是透明的。你也可以选择不同的默认UserDetailsService实现。
开始使用DaoAuthticationProvider最简单的方式是采用` InMemoryUserDetailsManager `。它使用内存数据库，不能用于生产环境中。只是作为演示目的。
但是本次使用的是常用的` JdbcUserDetailsManager `.
Spring Security通过一系列过滤器实现进行操作。**你应该总是在根应用上下文中配置它们。**
配置的两个关键步骤组成：**注册过滤器和创建安全限制。**

**1、创建Spring Security过滤器**
` WebApplicationInitializer `是Spring Framework用于初始化Servlet3.0应用程序的接口。Spring的` ServletContainerInitializer `实现将发现所有的WebApplicationInitializer实现并实例化它们。
Spring Security提供了WebApplicationInitializer的一个抽象实现` AbstractSecurityWebApplicationInitializer `。它将负责正确地注册所有安全相关的过滤器。不过，对所有过滤器排序时一定要小心。
```

import org.springframework.core.annotation.Order;
import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;

@SuppressWarnings("unused")
@Order(2) //对启动类进行排序，值越小优先级越高
public class SecurityBootstrap extends AbstractSecurityWebApplicationInitializer
{
    private static final Logger log = LogManager.getLogger();

   /*
   *为了启用登录并发控制，即同一个用户的登录人数限制。
   *Spring Security将使用它来发布HttpSession相关事件。
   *它将构建出一个会话注册表检测并发会话。
   **如果是XML方式配置，可以手动将监听器添加web.xml中
   <listener>
     <listener-class>org.springframework.security.web.session.HttpSessionEventPublisher</listener-class>
   </listener>
   */
    @Override
    protected boolean enableHttpSessionEventPublisher()
    {
        log.info("Executing security bootstrap.");
        return true;
    }
}

```
**如果不使用Java配置的方式，可以使用XML配置的方式达到同样的效果：**
```

  <listener>
     <listener-class>org.springframework.security.web.session.HttpSessionEventPublisher</listener-class> <!--为了启用登录并发控制，即同一个用户的登录人数限制。-->
   </listener>
 <filter>
        <filter-name>springSecurityFilterChain</filter-name> <!-- 这个Fileter name：springSecurityFilterChain是有意思的用于查找自动创建的过滤器bean。 -->
        <filter-class>
            org.springframework.web.filter.DelegatingFilterProxy
        </filter-class>
    </filter>
    <filter-mapping>
        <filter-name>springSecurityFilterChain</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

```

**2、配置登录机制和受保护的URL**
现在我们已经注册了Spring Security过滤器，接下来就可以在应用程序中配置Spring Security。将它添加到根应用上下文中。使用Java配置方式如下：
```

@Configuration 
...
@ComponentScan(
        basePackages = "com.wrox.site", 
        excludeFilters =
        @ComponentScan.Filter({Controller.class, ControllerAdvice.class})
)
  ....
@Import({ SecurityConfiguration.class }) //导入SpringSecurity的配置
public class RootContextConfiguration implements
        AsyncConfigurer, SchedulingConfigurer,TransactionManagementConfigurer
{
   。。。
}


```
```

@Configuration //必须的
@EnableWebMvcSecurity //SpringMVC项目使用@EnableWebMvcSecurity,否则使用@EnableWebSecurity
@EnableGlobalMethodSecurity( //启用方法保护注解，注意指定order，顺序特别重要。我们设定安全顺序为0，异步方法为1，事务支持为2.
        prePostEnabled = true, order = 0, mode = AdviceMode.PROXY, //使用prePost方式注解
        proxyTargetClass = false
)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter //必须继承WebSecurityConfigurerAdapter或实现WebSecurityConfigurer接口
{
  @Inject DataSource dataSource;
   @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception  //暴露AuthenticationManager为全局Bean。这样对于方法级别的保护才能生效。
    {
        return super.authenticationManagerBean();
    } 
   @Override
    protected void configure(AuthenticationManagerBuilder builder)
            throws Exception
    {
      /**
        builder
                .inMemoryAuthentication() //采用inMemoryAuthentication，生成环境不要使用。初始化配置两条用户认证和授权数据
                        .withUser("John")
                        .password("password")
                        .authorities("USER")
                    .and()
                        .withUser("Margaret")
                        .password("green")
                        .authorities("USER", "ADMIN");
       */
      builder.jdbcAuthentication()
            .dataSource(dataSource)
            .withDefaultSchema()
            .usersByUsernameQuery("select username, password,enabled from user where username = ?")
            .authoritiesByUsernameQuery("select username,permission from userpermission where username=?")
            .passwordEncoder(new BCryptPasswordEncoder()); //配置密码加密方式
    }

    @Override
    public void configure(WebSecurity security)
    {
        security.ignoring().antMatchers("/resource/**"); //忽略资源目录的扫描。
    }

    @Override
    protected void configure(HttpSecurity security) throws Exception
    {
        security
                .authorizeRequests() 
                    .antMatchers("/signup", "/about", "/policies").permitAll()
                    .antMatchers("/secure/**").hasAuthority("USER")
                    .antMatchers("/admin/**").hasAuthority("ADMIN")
                    .anyRequest().authenticated()
                .and().formLogin()  //表单登录
                    .loginPage("/login").failureUrl("/login?error")
                    .defaultSuccessUrl("/secure/")
                    .usernameParameter("username")
                    .passwordParameter("password")
                    .permitAll()
                .and().logout() //退出
                    .logoutUrl("/logout").logoutSuccessUrl("/login?loggedOut")
                    .invalidateHttpSession(true).deleteCookies("JSESSIONID") //退出时失效HttpSession，删除会话ID的Cookie
                    .permitAll()
                .and().sessionManagement()  //配置session管理
                   // .sessionFixation().changeSessionId() //针对Servlet3.1的防范会话固定攻击,不是必须的，以前的版本也有默认选项
                   // .maximumSessions(1).maxSessionsPreventsLogin(true) //配置同一用户同时只允许一个终端登录。当第二个终端尝试登录时，第二个登录将被禁止。第一个不受影响
          	     .maximumSessions(1).expiredUrl("/login?maxSessions")//配置同一用户同时只允许一个终端登录。当第二个终端尝试登录时，第一个将被挤掉线，然后重新返回登录页面。
                .and().and().csrf().disable(); //禁用CSRF请求伪造攻击保护。
      		//.rememberMe().key("myAppName").tokenValiditySeconds(22222) 提供记住我功能并设置过期时间，提供一个字段名为remember-me的复选框，如果使用XML配置时字段名为_spring_security_remember_me
    }
}


```
**如果需要使用XML配置方式，可以在RootContextConfiguration中使用@ImportResource而不是@Import导入配置：XML方式配置如下：**
```

<authentication-manager> <!-- AuthenticationManager管理AuthenticationProvider管理UserService管理User认证信息获取-->
    <authentication-provider>
     <!-- <user-service>
      	<user name="john" authorities="USER" password="111"/>  
        <user name="marry" authorities="ADMIN" password="111"/>  
      </user-service> -->
       <jdbc-user-service data-source-ref="dataSource" 
                          users-by-username-query="select username, password, true from spitter where username=?"  
       			authorities-by-username-query="select username,permission from spitter where username=?" />
      <password-encoder hash="bcrypt" />
    </authentication-provider>
  </authentication-manager>
<http security="none" pattern="/resource/**" />

<http auto-config="true" use-expressions="true">   <!-- use-expressions="true"开启SpEL -->
  <session-management session-fixation-protection="migrateSession" > <!--会话固定攻击防护，有几种选择：changeSessionId(只支持Servlet3.1以上),migrateSession(默认选项，将创建新的会话并复制所有现有特性),newSession,none -->
    <concurrency-control max-sessions="1" expired-url="login?maxSessions"/> <!--限制用户会话数量，为了启用该特性，记得配置前面所讲的特殊的监听器--> 
    </session-management>
  <!-- <remember-me key="myAppName" token-validity-seconds="2419200" />提供记住我功能，提供一个字段名为_spring_security_remember_me的复选框，如果使用Java配置时字段名为remember-me-->
  <form-login login-page="/login"
                login-processing-url="/login"  
                authentication-failure-url="/login?error"
                default-target-url="/home/"  <!--    默认情况下，我们在登录成功后会返回到原本受限制的页面。但如果用户是直接请求登录页面，登录成功后应该跳转到哪里呢？默认情况下它会跳转到当前应用的根路径，即欢迎页面。通过指定form-login元素的default-target-url属性，我们可以让用户在直接登录后跳转到指定的页面。-->
                username-parameter="username"
                password-parameter="password"/>
    <logout logout-url="/logout"
            logout-success-url="/index"
            invalidate-session="true"
            delete-cookies="JSESSIONID"/>
    <intercept-url pattern="/favicon.ico" access="permitAll" /> 
    <intercept-url pattern="/home" access="hasAuthority('USER')"/>
    <intercept-url pattern="/admin/**" 
        access="hasAuthority('ADMIN')"/>
    <intercept-url pattern="/spitter/form" requires-channel="https"/>
  </http>

```
默认情况下jdbc-user-service将
  * 使用SQL语句“select username, password, enabled from users where username = ?”来获取用户信息；
  * 使用SQL语句“select username, authority from authorities where username = ?”来获取用户对应的权限；
  * 使用SQL语句“select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id”来获取用户所属组的权限。
需要注意的是jdbc-user-service定义是不支持用户组权限的，所以使用jdbc-user-service时用户组相关表也是可以不定义的。如果需要使用用户组权限请使用JdbcDaoImpl，这个在后文后讲到。
当然这只是默认配置及默认的表结构。
  * users-by-username-query指定查询用户信息的SQL
  * authorities-by-username-query指定查询用户权限的SQL
  * group-authorities-by-username-query指定查询用户组权限的SQL

表达式	说明 
  * hasRole([role])	返回 true 如果当前主体拥有特定角色。 
  * hasAnyRole([role1,role2])	返回 true 如果当前主体拥有任何一个提供的角色 （使用逗号分隔的字符串队列） 
  * hasAuthority .如果用户指定了GrantedAuthority。
  * hasAnyAuthority(String ..)
  * principal	允许直接访问主体对象，表示当前用户 
  * authentication	允许直接访问当前 Authentication对象 从SecurityContext中获得 
  * permitAll	一直返回true 
  * denyAll	一直返回false 
  * isAnonymous()	如果用户是一个匿名登录的用户 就会返回 true 
  * isRememberMe()	如果用户是通过remember-me 登录的用户 就会返回 true 
  * isAuthenticated()	如果用户不是匿名用户就会返回true 
  * isFullyAuthenticated()	如果用户不是通过匿名也不是通过remember-me登录的用户时， 就会返回true。 
  * hasIpAddress(String)
##  编写自己的UserDetailsService 
` SecurityContextHolder `类含有一个当前请求相关的SecurityContext，通过它可以获取HTTP会话的Authentication。进一步获取相关信息。
```

  SecurityContext context = SecurityContextHolder.getContext();
        if(context != null && context.getAuthentication() != null)
            map.put("username", context.getAuthentication().getName());

```
使用实体` UserPrincipal `作为身份信息。
编写自己的AuthenticationProvider思路：**需要提供一个AuthenticationProvider实现，并在AuthenticationManager中注册它。**
1、转换用户主体和认证服务
` UserPrincipal `通过实现Authentication间接实现了Principal和Serializable。
```

@Validated
public interface UserAuthenticationService extends UserDetailsService
{
    @Override
    UserPrincipal loadUserByUsername(String username);

    void saveUser(
            @NotNull(message = "{validate.authenticate.saveUser}") @Valid
                UserPrincipal principal,
            String newPassword
    );
}

```
```

@Service //自动注册bean
public class DefaultUserAuthenticationService implements UserAuthenticationService //间接实现UserDetailsService接口
{
    private static final Logger log = LogManager.getLogger();
    private static final SecureRandom RANDOM;
    private static final int HASHING_ROUNDS = 10;

    static
    {
        try
        {
            RANDOM = SecureRandom.getInstance("SHA1PRNG");;
        }
        catch(NoSuchAlgorithmException e)
        {
            throw new IllegalStateException(e);
        }
    }

    /**
    *这个UserRepository就是一个JPA仓库
    public interface UserRepository extends CrudRepository<UserPrincipal, Long>
{
    UserPrincipal getByUsername(String username);
}
    */
    @Inject UserRepository userRepository; 

    @Override
    @Transactional //
    public UserPrincipal loadUserByUsername(String username) //返回一个UserPrincipal对象
    {
        UserPrincipal principal = this.userRepository.getByUsername(username); //从数据库中获取信息
       // make sure the authorities and password are loaded
        principal.getAuthorities().size();
        principal.getPassword();
        return principal;
    }

    @Override
    @Transactional
    public void saveUser(UserPrincipal principal, String newPassword) //保存新密码
    {
        if(newPassword != null && newPassword.length() > 0)
        {
            String salt = BCrypt.gensalt(HASHING_ROUNDS, RANDOM);
            principal.setPassword(BCrypt.hashpw(newPassword, salt).getBytes());
        }

        this.userRepository.save(principal);
    }
}

```
```

import org.springframework.security.core.GrantedAuthority;
import javax.persistence.Embeddable;

@Embeddable
public class UserAuthority implements GrantedAuthority
{
    private String authority;
    public UserAuthority() { }
    public UserAuthority(String authority)
    {
        this.authority = authority;
    }
    @Override
    public String getAuthority()
    {
        return this.authority;
    }
    public void setAuthority(String authority)
    {
        this.authority = authority;
    }
}

```
```

import org.springframework.security.core.CredentialsContainer;
import org.springframework.security.core.userdetails.UserDetails;
@Entity
@Table(uniqueConstraints = {
        @UniqueConstraint(name = "UserPrincipal_Username", columnNames = "user_name") //唯一性约束
})
public class UserPrincipal implements UserDetails, CredentialsContainer, Cloneable
{
    private static final long serialVersionUID = 1L;
    private long id;
    private String username;
    private String password;
    private Set<UserAuthority> authorities = new HashSet<>();
    private boolean accountNonExpired;
    private boolean accountNonLocked;
    private boolean credentialsNonExpired;
    private boolean enabled;
    @Id
    @GeneratedValue(generator = "system-uuid")
    @GenericGenerator(name = "system-uuid", strategy = "uuid")
    @Column(name = "user_id")
    public long getId()
    {
        return this.id;
    }
    public void setId(long id)
    {
        this.id = id;
    }
    @Override
    @Column(name = "user_name")
    public String getUsername()
    {
        return this.username;
    }

    public void setUsername(String username)
    {
        this.username = username;
    }

    @Override
    public void eraseCredentials()
    {
        this.setPassword(null);
    }

    @Override
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_authority", joinColumns = {
            @JoinColumn(name = "user_id", referencedColumnName = "user_id")
    })
    public Set<UserAuthority> getAuthorities()
    {
        return this.authorities;
    }

    public void setAuthorities(Set<UserAuthority> authorities)
    {
        this.authorities = authorities;
    }

    @Override
    public boolean isAccountNonExpired()
    {
        return this.accountNonExpired;
    }
    public void setAccountNonExpired(boolean accountNonExpired)
    {
        this.accountNonExpired = accountNonExpired;
    }

    @Override
    public boolean isAccountNonLocked()
    {
        return this.accountNonLocked;
    }
    public void setAccountNonLocked(boolean accountNonLocked)
    {
        this.accountNonLocked = accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired()
    {
        return this.credentialsNonExpired;
    }
    public void setCredentialsNonExpired(boolean credentialsNonExpired)
    {
        this.credentialsNonExpired = credentialsNonExpired;
    }

    @Override
    public boolean isEnabled()
    {
        return this.enabled;
    }
    public void setEnabled(boolean enabled)
    {
        this.enabled = enabled;
    }

    @Override
    public int hashCode()
    {
        return this.username.hashCode();
    }
    @Override
    public boolean equals(Object other)
    {
        return other instanceof UserPrincipal &&
                ((UserPrincipal)other).id == this.id;
    }

    @Override
    @SuppressWarnings("CloneDoesntDeclareCloneNotSupportedException")
    protected UserPrincipal clone()
    {
        try {
            return (UserPrincipal)super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e); // not possible
        }
    }

    @Override
    public String toString()
    {
        return this.username;
    }
    @Override
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
}


```
```

@Configuration //必须的
@EnableWebMvcSecurity //SpringMVC项目使用@EnableWebMvcSecurity,否则使用@EnableWebSecurity
@EnableGlobalMethodSecurity( //启用方法保护注解，注意指定order，顺序特别重要。我们设定安全顺序为0，异步方法为1，事务支持为2.
        prePostEnabled = true, order = 0, mode = AdviceMode.PROXY, //使用prePost方式注解
        proxyTargetClass = false
)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter //必须继承WebSecurityConfigurerAdapter或实现WebSecurityConfigurer接口
{
  @Inject DataSource dataSource;
  @Inject UserAuthenticationService authenticationService; //注入自定义的AuthenticationProvider实现
  
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception  //暴露AuthenticationManager为全局Bean。这样对于方法级别的保护才能生效。
    {
        return super.authenticationManagerBean();
    } 

    @Bean
    protected SessionRegistry sessionRegistryImpl()  //显式注册SessionRegistry的bean，这样就可以全局使用了。
    {
        return new SessionRegistryImpl();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder builder)
    {
        builder.userDetailsService(this.userService).passwordEncoder(new BCryptPasswordEncoder()).and().eraseCredentials(true); //注册自定义的Provider到manager中
    }
  @Override
    public void configure(WebSecurity security)
    {
        security.ignoring().antMatchers("/resource/**", "/favicon.ico");
    }

    @Override
    protected void configure(HttpSecurity security) throws Exception
    {
        security
                .authorizeRequests()
                    .anyRequest().authenticated()
                .and().formLogin()
                    .loginPage("/login").failureUrl("/login?loginFailed")
                    .defaultSuccessUrl("/ticket/list")
                    .usernameParameter("username")
                    .passwordParameter("password")
                    .permitAll()
                .and().logout()
                    .logoutUrl("/logout").logoutSuccessUrl("/login?loggedOut")
                    .invalidateHttpSession(true).deleteCookies("JSESSIONID")
                    .permitAll()
                .and().sessionManagement()
                    .sessionFixation().changeSessionId()
                    .maximumSessions(1).maxSessionsPreventsLogin(true)
                    .sessionRegistry(this.sessionRegistryImpl())  //配置sessionmanagement以便其知晓显式配置的SessionRegistry
                .and().and().csrf()
                    .requireCsrfProtectionMatcher((r) -> {
                        String m = r.getMethod();
                        return !r.getServletPath().startsWith("/services/") &&
                                ("POST".equals(m) || "PUT".equals(m) ||
                                        "DELETE".equals(m) || "PATCH".equals(m));
                    });
    }
}

```
如果想使用XML配置方式：
```

 <authentication-manager>
    <authentication-provider user-service-ref="userService" />
  </authentication-manager>

```
认证控制器
```

@WebController
public class AuthenticationController
{
   @RequestMapping("/login")
	public String login2(HttpServletRequest request, HttpServletResponse resp, LoginDto dto) {
		HttpSession session = request.getSession();
		// 如果早就登录了，那么直接跳转
		if (SecurityContextHolder.getContext().getAuthentication().getPrincipal() instanceof UserDetails) {
			ControllerUtil.redirectURL(resp, "/home");
			log.debug("已登录，直接跳转");
			return null;
		}
		session.setAttribute("loginId", UUID.randomUUID().toString());
		if(dto.getError()!=null){
			request.setAttribute("error", "用户名或密码错误");
			log.debug("用户名或密码错误");
		}else if(dto.getMaxSessions()!=null){
			request.setAttribute("error", "您的帐户在另一处登录，已强制退出");
			log.debug("用户数达到最大会话数");
		}else if(dto.getPage()!=null){
			
		}
		return "login";

	}

	@RequestMapping("/sessiontimeout")
	public void sessiontimeout(HttpServletRequest request,HttpServletResponse response){
		request.getSession().setAttribute("loginId", UUID.randomUUID().toString());
		String requestType = request.getHeader("X-Requested-With");
		// 如果是ajax请求
		if (StringUtils.checkEquals(requestType, "XMLHttpRequest")) {
			// 给前台传一个超时标志
			response.setHeader("sessionstatus", "timeout");
			log.debug("ajax请求超时处理");
			// 返回任意一个json串，防止前台报错
			try {
				response.getOutputStream().print("{\"status\":\"timeout\"}");
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				log.debug("ajax超时处理异常{}",e);
			}
		} else {
			// 如果是普通的浏览器HTTP请求。
			ControllerUtil.redirectURL(response, "/login");
			log.debug("HTTP session超时处理异常");
		}
	}

```
###  完整XML配置 
```

<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"
	xmlns:beans="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
                   http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-4.2.xsd
           http://www.springframework.org/schema/security
           http://www.springframework.org/schema/security/spring-security.xsd">
           
     <context:property-placeholder location="classpath:common.properties"/>	
     <beans:bean id="defaultUserAuthenticationService" class="net.xby1993.springmvc.security.service.DefaultUserAuthenticationService"/>
	<global-method-security pre-post-annotations="enabled" jsr250-annotations="enabled" access-decision-manager-ref="methodAccessDecisionManager" >
	 <expression-handler ref="methodSecurityExpressionHandler"/>
	</global-method-security>
	<authentication-manager> <!-- AuthenticationManager管理AuthenticationProvider管理UserDetailsService获取UserDetails认证信息 -->
		<authentication-provider
        				 user-service-ref="defaultUserAuthenticationService">
			<password-encoder hash="bcrypt" />
		</authentication-provider>
	</authentication-manager>
	<http security="none" pattern="/resource/**" />

	<http  use-expressions="true" access-decision-manager-ref="webAccessDecisionManager">   <!-- use-expressions="true"开启SpEL -->
		<expression-handler ref="webSecurityExpressionHandler"/>
		<!-- invalid-session-url指定处理Session超时的URL  -->
		<!--会话固定攻击防护，有几种选择：changeSessionId(只支持Servlet3.1以上),migrateSession(默认选项，将创建新的会话并复制所有现有特性),newSession,none -->
		<session-management session-fixation-protection="migrateSession" invalid-session-url="${host}/sessiontimeout"> 
			<concurrency-control max-sessions="1" expired-url="${host}/login?maxSessions=1" /> <!--限制用户会话数量，为了启用该特性，记得配置前面所讲的特殊的监听器 -->
		</session-management>
		<!-- <remember-me key="myAppName" token-validity-seconds="2419200" />提供记住我功能，提供一个字段名为_spring_security_remember_me的复选框，如果使用Java配置时字段名为remember-me -->
		<!-- login-page登录页面 ，
			login-processing-url并不也不能是实际地址，只是对于Spring Security一个标识，如果前台提交表单地址是这个就处理登录认证
			authentication-failure-url登录认证失败地址
			default-target-url如果是用户直接输入登录地址进行登录，那么登录成功后将进入该页面，否则就进入原先的页面。
			
			logout-url也是一个标记地址，不能是实际地址。用于Spring-Security处理退出。
			logout-success-url退出成功后进入的页面。
			-->
			
		<form-login login-page="${host}/login?page=1" 
			login-processing-url="/login11"  
			authentication-failure-url="${host}/login?error=1"
			default-target-url="${host}/home/"  
			username-parameter="username"
			password-parameter="password"/>
			<logout logout-url="/logout" logout-success-url="${host}/index"
				invalidate-session="true" delete-cookies="JSESSIONID" />
			<intercept-url pattern="/index" access="permitAll" />
			<intercept-url pattern="/login" access="permitAll" />
			<intercept-url pattern="/logout" access="permitAll" />
			<intercept-url pattern="/captcha/**" access="permitAll" />
			<intercept-url pattern="/home" access="hasAuthority('ROLE_USER')" />
			<intercept-url pattern="/admin/**" access="hasAuthority('ROLE_ADMIN')" />
			<intercept-url pattern="/upload/**" access="hasAuthority('ROLE_ADMIN')" />

	</http>
	 <!-- 角色继承 -->   
   <beans:bean id="roleHierarchy"
      class="org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl">
      <beans:property name="hierarchy"><!-- 角色继承关系 -->
         <beans:value>
            ROLE_ADMIN > ROLE_USER
         </beans:value>
      </beans:property>
   </beans:bean>
     <beans:bean id="roleHierarchyVoter"
      class="org.springframework.security.access.vote.RoleHierarchyVoter">
      <beans:constructor-arg ref="roleHierarchy" />
   </beans:bean>
 <!-- 用于web的ExpressionHandler -->
    <beans:bean id="webSecurityExpressionHandler" name="webSecurityExpressionHandler"
                class="org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler">
        <beans:property name="roleHierarchy" ref="roleHierarchy"/>
    </beans:bean>
 
    <!-- 用于method的ExpressionHandler -->
    <beans:bean id="methodSecurityExpressionHandler" class="org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler">
        <beans:property name="roleHierarchy" ref="roleHierarchy"/>
    </beans:bean>
   <!-- 用于web的ExpressionHandler -->   
 <beans:bean id="webAccessDecisionManager"  
    class="org.springframework.security.access.vote.AffirmativeBased">  
    <beans:property name="decisionVoters">  
        <beans:list>  
            <beans:bean class="org.springframework.security.web.access.expression.WebExpressionVoter">
                    <beans:property name="expressionHandler" ref="webSecurityExpressionHandler"/>
                </beans:bean>
                <beans:ref bean="roleHierarchyVoter" />  
                <beans:bean class="org.springframework.security.access.vote.AuthenticatedVoter"/>
        </beans:list>  
    </beans:property>  
</beans:bean> 
 <!-- 用于method的AccessDecisionManager -->
    <beans:bean id="methodAccessDecisionManager" class="org.springframework.security.access.vote.AffirmativeBased">
        <beans:constructor-arg>
            <beans:list>
                <beans:bean class="org.springframework.security.access.vote.RoleHierarchyVoter">
                    <beans:constructor-arg ref="roleHierarchy"/>
                </beans:bean>
                <beans:bean class="org.springframework.security.access.vote.AuthenticatedVoter"/>
                <beans:bean class="org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter">
                    <beans:constructor-arg name="pre">
                        <beans:bean class="org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice">
                            <beans:property name="expressionHandler" ref="methodSecurityExpressionHandler"/>
                        </beans:bean>
                    </beans:constructor-arg>
                </beans:bean>
                <beans:bean class="org.springframework.security.access.annotation.Jsr250Voter"/>
            </beans:list>
        </beans:constructor-arg>
    </beans:bean>
</beans:beans>

```

 **` SessionRegistry `的使用**
```

 List<SessionInformation> sessions = new ArrayList<>();
        for(Object principal : this.sessionRegistry.getAllPrincipals())
            sessions.addAll(this.sessionRegistry.getAllSessions(principal, true));

        model.put("timestamp", System.currentTimeMillis());
        model.put("numberOfSessions", sessions.size());
        model.put("sessionList", sessions);

```
##  PasswordEncoder 
使用内置的PasswordEncoder
通常我们保存的密码都不会像之前介绍的那样，保存的明文，而是加密之后的结果。为此，我们的AuthenticationProvider在做认证时也需要将传递的明文密码使用对应的算法加密后再与保存好的密码做比较。Spring Security对这方面也有支持。
```

   <security:authentication-manager>
      <security:authentication-provider user-service-ref="userDetailsService">
         <security:password-encoder hash="bcrypt"/>
      </security:authentication-provider>
   </security:authentication-manager>

```
其属性hash表示我们将用来进行加密的哈希算法，系统已经为我们实现的有plaintext、sha、sha-256、md4、md5、bcrypt、{sha}和{ssha}。它们对应的PasswordEncoder实现类如下：
加密算法
PasswordEncoder实现类
plaintext PlaintextPasswordEncoder
sha ShaPasswordEncoder
sha-256 ShaPasswordEncoder，使用时new ShaPasswordEncoder(256)
md5 Md5PasswordEncoder
{sha} LdapShaPasswordEncoder
{ssha} LdapShaPasswordEncoder
使用BASE64编码加密后的密码
此外，使用password-encoder时我们还可以指定一个属性base64，表示是否需要对加密后的密码使用BASE64进行编码，默认是false。如果需要则设为true。
<security:password-encoder hash="md5" base64="true"/>
加密时使用salt
加密时使用salt也是很常见的需求，Spring Security内置的password-encoder也对它有支持。通过password-encoder元素下的子元素salt-source，我们可以指定当前PasswordEncoder需要使用的salt。这个salt可以是一个常量，也可以是当前UserDetails的某一个属性，还可以通过实现SaltSource接口实现自己的获取salt的逻辑，SaltSource中只定义了如下一个方法。
public Object getSalt(UserDetails user);
下面来看几个使用salt-source的示例。
```

（1）下面的配置将使用常量“abc”作为salt。
   <security:authentication-manager>
      <security:authentication-provider user-service-ref="userDetailsService">
         <security:password-encoder hash="md5" base64="true">
            <security:salt-source system-wide="abc"/>
         </security:password-encoder>
      </security:authentication-provider>
   </security:authentication-manager>
 
       （2）下面的配置将使用UserDetails的username作为salt。
   <security:authentication-manager>
      <security:authentication-provider user-service-ref="userDetailsService">
         <security:password-encoder hash="md5" base64="true">
            <security:salt-source user-property="username"/>
         </security:password-encoder>
      </security:authentication-provider>
   </security:authentication-manager>
 
       （3）下面的配置将使用自己实现的SaltSource获取salt。其中mySaltSource就是SaltSource实现类对应的bean的引用。
   <security:authentication-manager>
      <security:authentication-provider user-service-ref="userDetailsService">
         <security:password-encoder hash="md5" base64="true">
            <security:salt-source ref="mySaltSource"/>
         </security:password-encoder>
      </security:authentication-provider>
   </security:authentication-manager>

```
需要注意的是AuthenticationProvider进行认证时所使用的PasswordEncoder，包括它们的算法和规则都应当与我们保存用户密码时是一致的。也就是说如果AuthenticationProvider使用Md5PasswordEncoder进行认证，我们在保存用户密码时也需要使用Md5PasswordEncoder；如果AuthenticationProvider在认证时使用了username作为salt，那么我们在保存用户密码时也需要使用username作为salt。如：

1.2.2   使用自定义的PasswordEncoder
除了通过password-encoder使用Spring Security已经为我们实现了的PasswordEncoder之外，我们也可以实现自己的PasswordEncoder，然后通过password-encoder的ref属性关联到我们自己实现的PasswordEncoder对应的bean对象。
 ```

  <security:authentication-manager>
      <security:authentication-provider user-service-ref="userDetailsService">
         <security:password-encoder ref="passwordEncoder"/>
      </security:authentication-provider>
   </security:authentication-manager>
  
   <bean id="passwordEncoder" class="com.xxx.MyPasswordEncoder"/>

```
在Spring Security内部定义有两种类型的PasswordEncoder，分别是org.springframework.security.authentication.encoding.PasswordEncoder和org.springframework.security.crypto.password.PasswordEncoder。直接通过password-encoder元素的hash属性指定使用内置的PasswordEncoder都是基于org.springframework.security.authentication.encoding.PasswordEncoder的实现，然而它现在已经被废弃了，` Spring Security推荐我们使用org.springframework.security.crypto.password.PasswordEncoder，它的设计理念是为了使用随机生成的salt。 `关于后者Spring Security也已经提供了几个实现类，更多信息请查看Spring Security的API文档。我们在通过password-encoder使用自定义的PasswordEncoder时两种PasswordEncoder的实现类都是支持的。

###  Spring Security与事件消息 
通过Spring Framework的发布-订阅消息，Spring Security在发生特定的认证事件时可以发布各种消息。常用的一些事件:
  * AbstractAuthenticationFailureEvent:认证失败时发布该事件
  * AuthenticationSuccessEvent认证成功时发布
  * InteractiveAuthenticationSuccessEvent交互式认证成功时发布。
  * SessionFixationProtectionEvent：当会话固定攻击保护引起会话改变时发布。
  * SessionDestoryedEvent：会话销毁时发布（退出或者会话超时时）
##  保护方法调用 
首先开启注解支持:
```

<!-- <global-method-security secured-annotations=“enabled” /> 针对Spring Security注解@Secured -->
<global-method-security jsr250-annotations=“enabled” /> 针对JSR-250标准注解@RolesAllowed ,推荐使用 位于javax.annotation.security包中。还有@PermitAll等注解

```
使用` @Secured `注解保护方法调用
```

@RolesAllowed("ROLE_ADMIN")或者@RolesAllowed({"ROLE_ADMIN","ROLE_SPITTER"}) 只需具备其中之一
public void add(){}

``` 
**如果想使用SpEL实现调用前后的安全性**。即注解` @PreAuthorize,@PostAuthorize `
启用这一功能：
```

<global-method-security pre-post-annotations=“enabled” />

```
如果没有相关权限。就会抛出AccessDeniedException，Spring Security过滤器捕获该异常并返回一个403 Forbidden错误给用户

@PreAuthorize注解可以访问方法参数，通过"#参数名"的形式。
后续文章会具体介绍。

参考：http://liukai.iteye.com/blog/982088/
http://www.ibm.com/developerworks/cn/java/j-lo-springsecurity/
http://haohaoxuexi.iteye.com/blog/2154714
http://blog.csdn.net/wyabc1986/article/details/8424688