title: nosql介绍与入门 

#  NoSQL介绍与入门 
为弥补关系型数据库的不足，各种各样的NoSQL数据库应运而生。

关系型数据库作为应用广泛的通用型数据库，它的突出优势主要有以下几点:   
  * 保持数据的一致性（事务处理）  
  * 由于以标准化为前提，数据更新的开销很小（相同的字段基本上都只有一处）
  * 可以进行JOIN等复杂查询
  * 存在很多实际成果和专业技术信息（成熟的技术） 

**关系型数据库的不足**
就像之前提到的那样，关系型数据库的性能非常高。但是它毕竟是一个通用型的数据库，并不能完全适应所有的用途。具体来说它并不擅长以下处理： 
  * 大量数据的写入处理  
  * 为有数据更新的表做索引或表结构（schema）变更
  * 字段不固定时应用
  * 对简单查询需要快速返回结果的处理 
**传统关系型数据库面临的挑战**
  * l High Performance——对数据库高并发读写的需求
  * l Huge Storage——对海量数据的高效率存储的需求
  * l High Scalability & High Availablity——对数据库的高可扩展性和高可用性的需求。
  * 关系型数据库的特性地位下降
················· 事务一致性
················· 读写实时性
················· 复杂SQL，特别是多表关联查询
利用NoSQL的好处。 
  * 希望顺畅地对数据进行` 缓存（Cache）处理 `
  * 希望对数组类型的数据进行高速处理
  * 希望进行全部保存
**NoSQL数据库**
为了弥补关系型数据库的不足（特别是最近几年），NoSQL数据库出现了。关系型数据库应用广泛，能进行事务处理和JOIN等复杂处理。相对地，
**NoSQL数据库只应用在特定领域，基本上不进行复杂的处理，**但它恰恰**弥补了之前所列举的关系型数据库的不足之处。**
易于数据的分散
如前所述，关系型数据库并不擅长大量数据的写入处理。原本关系型数据库就是以JOIN为前提的，就是说，各个数据之间存在关联是关系型数据库得名的主要原因。为了进行JOIN处理，关系型数据库不得不把数据存储在同一个服务器内，这不利于数据的分散。相反，NoSQL数据库原本就不支持JOIN处理，各个数据都是独立设计的，**很容易把数据分散到多个服务器上。**由于数据被分散到了多个服务器上，减少了每个服务器上的数据量，即使要进行大量数据的写入操作，处理起来也更加容易。同理，数据的读入操作当然也同样容易。

**多样的NoSQL数据库**
NoSQL数据库存在着**“key-value存储”、“文档型数据库”、“列存储数据库”**等各种各样的种类，每种数据库又包含各自的特点。下一节让我们一起来了解一下NoSQL数据库的种类和特点。

##  NoSQL数据库是什么 
NoSQL说起来简单，但实际上到底有多少种呢？竟然已经有122种了。不知不觉间，原来已经出现了这么多的NoSQL数据库啊。 
本节将为大家介绍具有代表性的NoSQL数据库。

###  1、key-value存储，通常作为缓存数据库 
这是最常见的NoSQL数据库，它的数据是以key-value的形式存储的。虽然它**的处理速度非常快**，但是基本上只能通过key的完全一致查询获取数据。根据数据的保存方式可以**分为临时性、永久性和两者兼具三种**。
  * **a、临时性**
` memcached `属于这种类型。所谓**临时性就是 “数据有可能丢失”**的意思。**memcached把所有数据都保存在内存中，这样保存和读取的速度非常快，但是当memcached停止的时候，数据就不存在了**。由于数据保存在内存中，所以无法操作超出内存容量的数据（旧数据会丢失）。 
  *   * 在内存中保存数据
  *   * 可以进行非常快速的保存和读取处理
  *   * 数据有可能丢失

  *** b、永久性**
` Tokyo Tyrant、Flare、ROMA `等属于这种类型。和临时性相反，所谓永久性就是“数据不会丢失”的意思。**这里的key-value存储不像memcached那样在内存中保存数据，而是把数据保存在硬盘上。**与memcached在内存中处理数据比起来，由于必然要发生对硬盘的IO操作，所以性能上还是有差距的。但数据不会丢失是它最大的优势。 
  *   * 在硬盘上保存数据
  *   * 可以进行非常快速的保存和读取处理（但无法与memcached相比）
  *   * 数据不会丢失

  * **c、两者兼具**
` Redis `属于这种类型。**Redis有些特殊，临时性和永久性兼具，且集合了临时性key-value存储和永久性key-value存储的优点。Redis首先把数据保存到内存中，在满足特定条件（默认是15分钟一次以上，5分钟内10个以上，1分钟内10000个以上的key发生变更）的时候将数据写入到硬盘中。**这样既确保了内存中数据的处理速度，又可以通过写入硬盘来保证数据的永久性。**这种类型的数据库特别适合于处理数组类型的数据。**
  *   * 同时在内存和硬盘上保存数据
  *   * 可以进行非常快速的保存和读取处理
  *   * 保存在硬盘上的数据不会消失（可以恢复）
  *   * 适合于处理数组类型的数据

###  2、面向文档的数据库 
` MongoDB、CouchDB `属于这种类型。它们属于NoSQL数据库，但与key-value存储相异。 
**不定义表结构**
面向文档的数据库具有以下特征：即使不定义表结构，也可以像定义了表结构一样使用。关系型数据库在变更表结构时比较费事，而且为了保持一致性还需修改程序。然而NoSQL数据库则可省去这些麻烦（通常程序都是正确的），确实是方便快捷。 
可以使用复杂的查询条件
跟key-value存储不同的是，**面向文档的数据库可以通过复杂的查询条件来获取数据。虽然不具备事务处理和JOIN这些关系型数据库所具有的处理能力，但除此以外的其他处理基本上都能实现。**这是非常容易使用的NoSQL数据库。 
  * 不需要定义表结构
  * 可以利用复杂的查询条件

###  3、面向列的数据库 

` Cassandra、Hbase、HyperTable `属于这种类型。由于近年来数据量出现爆发性增长，这种类型的NoSQL数据库尤其引人注目。 
面向行的数据库和面向列的数据库
普通的关系型数据库都是以行为单位来存储数据的，擅长进行以行为单位的读入处理，比如特定条件数据的获取。因此，**关系型数据库也被称为面向行的数据库**。相反，面向列的数据库是以列为单位来存储数据的，擅长以列为单位读入数据。 
高扩展性
**面向列的数据库具有高扩展性，即使数据增加也不会降低相应的处理速度（特别是写入速度）**，所以它**主要应用于需要处理大量数据的情况。**另外，利用面向列的数据库的优势，把它作为批处理程序的存储器来对大量数据进行更新也是非常有用的。但由于面向列的数据库跟现行数据库存储的思维方式有很大不同，应用起来十分困难。 
高扩展性（特别是写入处理）
应用十分困难
最近，像Twitter和Facebook这样需要对大量数据进行更新和查询的网络服务不断增加，面向列的数据库的优势对其中一些服务是非常有用的，但是由于这与本书所要介绍的内容关系不大，就不进行详细介绍了。

总结：
NoSQL并不是No-SQL，而是指Not Only SQL。
NoSQL的出现是为了弥补SQL数据库因为事务等机制带来的**对海量数据、高并发请求的处理的性能上的欠缺。**
NoSQL不是为了替代SQL而出现的，它是一种替补方案，而不是解决方案的首选。
绝大多数的NoSQL产品都是基于大内存和高性能随机读写的（比如具有更高性能的固态硬盘阵列），**一般的小型企业在选择NoSQL时一定要慎重！不要为了NoSQL而NoSQL，可能会导致花了冤枉钱又耽搁了项目进程。**
**NoSQL不是万能的，但在大型项目中，你往往需要它！**

##  附录：ACID vs. BASE 
` ACID `，指数据库事务正确执行的四个基本要素的缩写。包含：
  * 原子性(Atomicity）、
  * 一致性（Consistency）、
  * 隔离性（Isolation）、
  * 持久性（Durability）。 
` BASE `内容：
  * l Basically Availble ——基本可用
  * l Soft-state ——软状态/柔性事务，状态可以有一段时间不同步
  * l Eventual Consistency ——最终一致性
![](/data/dokuwiki/database/pasted/20151013-092946.png?400x250)
##  附录：CAP原理 
分布式系统中，有三种重要的属性，分别是：
  * l 一致性(Consistency)：任何一个读操作总是能读取到之前完成的写操作结果，也就是在分布式环境中，多点的数据是一致的。
  * l 可用性(Availability)：每一个操作总是能够在确定的时间内返回，也就是系统随时都是可用的。
  * l 分区容忍性(Tolerance of network Partition)：在出现网络分区（比如断网）的情况下，分离的系统也能正常运行。

<note tip>CAP原理的意思是，一个分布式系统不能同时满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个。</note>
在NoSQL的世界中，它还是非常有参考价值的。
 
注意：可用性与分区容忍性在一些情况下很容易混淆。举个例子，假设系统中有若干个节点宕机了，系统仍然能正常运行，那么应该说是系统的可用性高还是分区容忍性高呢？个人的理解是，这种应该理解为系统的分区容忍性高。因为若干个节点宕机，可以理解为这几个节点与其它正常的节点失去联系了，也就是出现了网络分区，按照定义，这属于分区容忍性的范畴。那么可用性是什么？个人的理解**可用性更多强调的是，系统对于读写操作的反应快慢，反应越快，可用性越高。**
###  一致性or可用性，鱼和熊掌不可得兼 
下面是一个牺牲一致性换取可用性的小例子。
假设N1和N2是分布式环境下的两个节点，它们有保存了共同的数据V，它们的值都是V0，A和B是两个分别对数据进行操作的进程。我们看看这么一个过程：A向N1节点写入了新的V值V1，B读取V的值。
![](/data/dokuwiki/database/pasted/20151013-093532.png)
如果一切正常的话，这个过程看起来像是这样的：
![](/data/dokuwiki/database/pasted/20151013-093546.png)
(1) A写入V的新值V1。
(2) N1向N2发送消息M以更新V值。
(3) B读取V的新值V2。 
 
但是现实可能是这样子的：
![](/data/dokuwiki/database/pasted/20151013-093600.png)
由于网络分区，N1发向N2的消息很有可能没送达，那么，B节点将读取到一个过时的V值，不一致性产生了。并且当把节点的规模不断扩大的时候，不一致性问题也会更加严重。
所以如果我们希望A B都是**高可用的（也就是低延迟）**，**那么一致性通常就不能得到很好的保证，我们必须要容忍一定的不一致性以换取高可用性。**

**从客户端角度看一致性**
有很多种客户端一致性模型：
  * 强一致性：读取到的数据总是最新的。
  * 弱一致性：读取到的数据不一定是最新的。
  * 最终一致性：属于弱一致性，不同的是，最终一致性的系统会在后台异步地更新所有的备份，所以最终所有的备份都会是最新的数据。
  * 最终一致性有一些比较重要的变种，例如：
  * 因果一致性：如果进程A更新了某数据，并通知进程B，那么进程B接下来的读操作将一定会读取到最新的数据，写操作一定能覆盖之前的数据。而另一与进程A无关的进程C则服从最终一致性的情况。
“读己之所写”一致性：客户端可以立即看到自己所作的更新，但不能立即看到其他客户端的更新。
会话一致性：对于客户端在一同会话作用域中发起的请求，提供“读己之所写”一致性。
  * 单调读一致性：保证时间上的单调性，保证客户端在未来的请求中，只会读到比当前更为新的数据。

**从服务器端角度看一致性**
Quorum NRW 模型
先看下面这个图，并定义一些变量。
![](/data/dokuwiki/database/pasted/20151013-093846.png)
 
l N：存储备份的节点数目，可以理解为备份的数目。
l W：更新（写）操作成功之前所必须更新的最少备份数目。假设W=3，表示至少等到3个备份的数据得到更新时，更新操作才算完成。
l R：读操作所需要连接的最少备份数目。假设R=3，表示读取一个数据时，至少要读取到这个数据的3个备份，然后选其中最新的备份。
 
调整N、W、R的取值，数据库系统的性质就会发生改变。
l N越大，同一个数据的备份越多，系统相对也就越不容易丢失数据。
l W越大，系统的一致性会越高，但更新操作也就越慢。
l R越大，系统的一致性会越高，但读操作也就越慢。
l **W+R>N，系统是强一致性的**。为什么？举例来说，假设N=6，W=R=3，当一个更新操作完成的时候，它至少更新了6个备份中的3个备份，那么当我们去读取这个数据的时候，因为R=3，所以我们至少得读3个数据，并从中选择最新的数据，**而W+R>N就意味着读取的3个数据跟更新的3个数据至少有一个是重叠的，所以读取的3个数据中一定存在最新的数据，因而就能保证系统是强一致性的。**
**l W+R<=N，系统是弱一致性的。**
 
几种特殊情况：
l W = 1，R = N，对写操作要求高性能**高可用。**
l R = 1，W = N，对读操作要求高性能**高可用**，比如类似cache之类业务。
l W = R = N / 2 + 1 一般应用适用，读写性能之间取得平衡。如N=3，W=2，R=2。
参考：
http://blog.csdn.net/xyz_lmn/article/details/8052348
http://blog.sina.com.cn/s/blog_3fe961ae010139u6.html
http://renial.iteye.com/blog/684829