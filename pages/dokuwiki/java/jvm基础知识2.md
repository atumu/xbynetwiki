title: jvm基础知识2 

#  JVM内存结构 
在Java语言开发过程中，out of memory错误是很常见的一种错误。对于JVM的内存结构有更深入的了解，更更好的帮我们排查此类问题，有效的避免此类问题发生。
在JAVA 8中内存结构有进行了改变，Metaspace替代了PermGen(永生代)。
内存结构简介
JVM的内存结构如下图所示：
![](/data/dokuwiki/java/pasted/20160330-104546.png)
JVM的内存结构大概分为：
  * 堆（heap）：线程共享，所有的**对象实例以及数组**都要在堆上分配。回收器主要管理的对象。
  * 方法区（MEATHOD AREA）：线程共享，存储**类信息、常量、静态变量**、即时编译器编译后的代码。
  * PC寄存器（PC Register）：线程私有。指向下一条要执行的指令。
  * 方法栈（JVM Stack）：线程私有、存储**局部变量表、操作栈**、动态链接、方法出口，对象指针。
  * 本地方法栈（NATIVE METHOD STACK）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。

各区域详细说明
先看一张图，这张图能很清晰的说明JVM内存结构的布局和相应的控制参数：（图片来源于网络）
![](/data/dokuwiki/java/pasted/20160330-104719.png)
##  堆 
**堆的作用是存放对象实例和数组。**堆从结构上来分，可以**分为新生代和老生代**。
而新生代又可以分为Eden 空间、From Survivor 空间（s0）、To Survivor 空间（s1）。 所有新生成的对象首先都是放在年轻代（Eden）的。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。

控制参数
-Xms设置堆的最小空间大小。-Xmx设置堆的最大空间大小。-XX:NewSize设置新生代最小空间大小。-XX:MaxNewSize设置新生代最小空间大小。

垃圾回收
此区域是**垃圾回收的主要操作区域**。

异常情况
如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出` OutOfMemoryError 异常 `。

##  方法区 
方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。
很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚
拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。在Java8中永生代彻底消失了。

控制参数
-XX:PermSize 设置最小空间 -XX:MaxPermSize 设置最大空间
垃圾回收
对此区域会涉及但是很少进行垃圾回收。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意。

异常情况
根据Java 虚拟机规范的规定， 当方法区无法满足内存分配需求时， 将抛出` OutOfMemoryError 异常 `。

##  PC计数器 
它的作用可以看做是当前线程所执行的字节码的**行号指示器**。
异常情况
此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。
##  方法栈 
每个线程会有一个**私有的栈**。每个线程中方法的调用又会在本栈中创建一个**栈帧**。在方法栈中会存放编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，**这个方法需要在帧中分配多大的局部变量空间是完全确定的**，在方法运行期间不会改变局部变量表的大小。

控制参数
-Xss控制每个线程栈的大小。

异常情况
在Java 虚拟机规范中，对这个区域规定了两种异常状况：
  * 将抛出` StackOverflowError `： 异常线程请求的栈深度大于虚拟机所允许的深度时抛出；
  * ` OutOfMemoryError ` 异常： 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出。

##  本地方法栈 
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。

控制参数
在Sun JDK中本地方法栈和方法栈是同一个，因此也可以用-Xss控制每个线程的大小。

异常情况
与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。
参考资料
http://blog.chinaunix.net/uid-9789791-id-3350463.html
